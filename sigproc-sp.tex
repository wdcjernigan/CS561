% THIS IS SIGPROC-SP.TEX - VERSION 3.1
% WORKS WITH V3.2SP OF ACM_PROC_ARTICLE-SP.CLS
% APRIL 2009
%
% It is an example file showing how to use the 'acm_proc_article-sp.cls' V3.2SP
% LaTeX2e document class file for Conference Proceedings submissions.
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V3.2SP) *DOES NOT* produce:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) Page numbering
% ---------------------------------------------------------------------------------------------------------------
% It is an example which *does* use the .bib file (from which the .bbl file
% is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission,
% you need to 'insert'  your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% Questions regarding SIGS should be sent to
% Adrienne Griscti ---> griscti@acm.org
%
% Questions/suggestions regarding the guidelines, .tex and .cls files, etc. to
% Gerald Murray ---> murray@hq.acm.org
%
% For tracking purposes - this is V3.1SP - APRIL 2009

\documentclass{acm_proc_article-sp}
\usepackage[utf8]{inputenc}
\usepackage[Russian]{babel}
\begin{document}

\title{Mobile JavaScript Library Minimization}
\subtitle{Milestone Two}
%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\numberofauthors{3} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor
William Jernigan\\
       \affaddr{Oregon State University}\\
       \affaddr{Corvallis, OR 97331}\\
       \email{wdcjernigan@gmail.com}
% 2nd. author
\alignauthor
William Leslie\\
       \affaddr{Oregon State University}\\
       \affaddr{Corvallis, OR 97331}\\
       \email{lesliew@onid.oregonstate.edu}
% 3rd. author
\and
\alignauthor Francis Vo\\
       \affaddr{Oregon State University}\\
       \affaddr{Corvallis, OR 97331}\\
       \email{vof@onid.oregonstate.edu}
}
% There's nothing stopping you putting the seventh, eighth, etc.
% author on the opening page (as the 'third row') but we ask,
% for aesthetic reasons that you place these 'additional authors'
% in the \additional authors block, viz.
% \additionalauthors{Additional authors: John Smith (The Th{\o}rv{\"a}ld Group,
% email: {\texttt{jsmith@affiliation.org}}) and Julius P.~Kumquat
% (The Kumquat Consortium, email: {\texttt{jpkumquat@consortium.net}}).}
% \date{30 July 1999}
% Just remember to make sure that the TOTAL number of authors
% is the number that will appear on the first page PLUS the
% number that will appear in the \additionalauthors section.

\maketitle
% \begin{abstract}
% Abstract here...
% \end{abstract}

% A category with the (minimum) three required fields
% \category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
% \category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]

% \terms{Theory}

% \keywords{ACM proceedings, \LaTeX, text tagging} % NOT required for Proceedings

\section{Research overview}
Mobile devices load entire JavaScript libraries when users browse the web.
This can make the mobile device slow or unresponsive if the library is large and/or if the mobile deviceâ€™s resources are limited, which may lead users to look for another website to use or download an app instead of using the mobile browser.
Traditional guidelines were made to improve load times and usability of these websites.
JavaScript libraries are often minified to create smaller files allowing for faster download times for the files.
80\% of web page loading time is attributed to loading page resources and only 20\% is from back-end computations \cite{souders2008high}, so loading is a large concern for websites.
Another approach to counter download times is hybrid applications; these store most of the JavaScript files on the device to avoid delays due to server communication.
This means that the traditional guidelines for websites do not apply to hybrid applications.
 To provide new guidelines, we propose the following research questions:

RQ1: Do guidelines for the loading of websites on mobile devices apply to hybrid applications?\\
RQ2: If not, what new guidelines can be provided to improve the performance of hybrid applications?

\section{Motivating Example}
A web application designer, John, made an app, but decided that he wanted it to be mobile compatible.
He decided the best way to do this was to make a hybrid app, which would make the application run more natively than on a browser.
This makes the application faster on mobile devices, since not as much data has to be downloaded over a slow mobile network.
He gets complaints that the application is slow to load, so he researches possible solutions.
One tool John found was the Google Closure Compiler.
This software minifies John's JavaScript files and removes unused lines of code from his program.
He reasons that a smaller file would be quicker to parse than a large file.
He uses this tool on all of his JavaScript files and pushes out the update.
He continues to get complaints that the application is slow.
Upon closer inspection, John finds that Google Closure Compiler does not remove entire functions, even though some of them go unused.  

\section{Technical Challenges}
%For the next iteration, add a section about the technical challenges (i.e., what are the hard problems, why is this research non trivial). For example, you could talk about measuring accurately the runtime performance, dependencies, the dynamic nature of JS etc.
Several factors make this research technically challenging.
First, using traditional techniques on hybrid apps and determining if speed ups have occurred requires minifying and profiling on a large corpus of applications.
This means the applications must be retrieved, processed, and judged for improvements with a process we design.
Second, we must determine new guidelines to use for hybrid applications that could potentially improve performance.
Current literature does not provide many recommendations for this type of application, although PhoneGap developers do make some recommendations based on experience.
Third, we must use similar techniques as in the first step, where we test the guidelines we propose by processing the applications and measuring their performance.  We will then report which guidelines make a difference.

\subsection{Answering RQ1}
% Automatically running Google CC on many applications requires making the HTML files refer to the new compiled versions of the JavaScript
To determine the (lack of) gains when using the Google Closure Compiler on a hybrid application, a nontrivial problem makes the process challenging.
First, if we run the Closure Compiler on all of an application's JavaScript files at once, it combines them into one JavaScript file (which fits a recommendation at https://codedrop.com.au/blog/phonegap-performance-tips). 
Then we must change the references in all the HTML files to include just this newly compiled JavaScript file instead of including all the old files.
If we run the Closure Compiler on each of the application's JavaScript files separately, the HTML modification is not required, but then the Closure Compiler cannot make gains in combining sections of code from across files, reducing its effectiveness. 
So, it may be necessary to either try both approaches or find the best way to modify the HTML so the Closure Compiler is given an honest shot at making a difference.

\section{Proposed Solution}
In order to show that the traditional web page guidelines do not apply to hybrid applications, we will first use the Google Closure Compiler to create a version of the hybrid application which is minified.
Then we will test its speed with Android Device Monitor with the expectation that there will be miniscule improvements.
Below is a discussion of the current challenges with each required technology.

\subsection{Retrieving applications}
First, we will build a corpus of applications to test our process. 
We target PhoneGap applications, but need to determine which apps are open source. 
Doing this manually requires searching for the applications in repositories hosted at sites like Github or Google Code.
Determining that the correct application has been found potentially requires human intelligence (or is hard to automate) because one or more factors may confirm that the correct application has been found, including author name, images of the application, release dates, etc.
Automating this process appears to be potentially possible, but using a simple automated process and just using the applications we can get is likely the best approach.

\subsection{Google Closure Compiler}
After obtaining the applications, we will measure performance (loading speed, etc.) before and after modifying the application with the Google Closure Compiler. 
Using this tool creates the challenges described in section Answering RQ1, including requiring modification of all HTML files to refer to the compiled JavaScript file(s), or compiling one JavaScript file at a time, reducing the Closure Compiler's effectiveness. 

\subsection{KJSCompiler}
KJSCompiler is a wrapper for Google Closure Compiler that allows the user to provide annotations with information about dependencies to be used.
When KJSCompiler is run, it compiles the JavaScript files in the order that the dependency annotations dictate.
This allows for the correct ordering of function and value declarations when compiling over multiple files.
The downside to this software is that the user needs to have dependence information in each file. 
This is worsened if the user does not understand the dependence structure of the target system very well. 
Using the KJSCompiler in our case would require automating the determination of dependencies between files of an arbitrary file structure, which may be too complex considering the limited gains to be had.


\subsection{Ineffective traditional guidelines}
We will use Google Closure Compiler to turn a hybrid app into a minified hybrid app.
The closure compiler uses traditional guidelines for optimizing mobile web apps.
Then we will test both the normal and minified versions of the hybrid apps.
Our hypothesis is that the performance of normal and minified versions will be very similar.
The traditional guidelines are used to create an optimized javascript files that are transferred over the internet to the user device.
Unlike mobile web apps, hybrid apps have the JavaScript files on the device on execution.
This means that file size and other minification guidelines might not affect performance as much as they would for web apps.


\subsection{New Guidelines}
After proving that traditional guidelines are ineffective, we will test and validate that new guidelines are more effective for hybrid apps.
Aharon has suggested some new guidelines that will be more effective on hybrid apps:
\begin{enumerate}
	\item Creating smaller files using minification
	\item Load only functions needed for that page
\end{enumerate}

We also did some research and found some performance techniques used by Phonegap developers:
\begin{enumerate}
	\item Avoid Network access
	\item Don't wait for data to display
	\item Use CSS Transitions
	\item Use Native functions
	\item Avoid Click event delay
	\item Use CSS Sprite Sheets
	\item Limit some UI functions
	\item Limit access to DOM
	\item limit libraries and frameworks
\end{enumerate}


\section{Related Works}

\subsection{Digua: Minifier and Obfuscator for Web Resources\cite{ciminiandigua} }
Authors Alex Ciminian and Ciprian Dobre discuss their minifier tool Digua. 
Digua is a minifier which works for CSS, HTML, and JavaScript.  
It will find correlations between these different languages to further reduce the size of these files.
The paper states that 80\% of web page loading time is attributed to loading page resources and only 20\% is from back-end computations and the reduced file size will result in much increased web page responsiveness.
This does not apply to hybrid mobile apps.
This is because the web code for the application is already stored in the device.
The method presented in the paper would only apply to applications which need to be downloaded every time the website is hit. 



\subsection{Semi-Automatic Rename Refactoring for JavaScript\cite{feldthaus2013semi}}
Authors Asger Feldthaus and Anders Moller discuss a method for renaming functions using a combination of static analysis and programmer input.
While this does not apply directly to our project, it does bring up issues involved with renaming in JavaScript.
For instance, similarly named features of the code may be renamed when they should not be.
This will lead to a lot of errors in the code.
This is a limitation to minification methods as well, since, in order to maintain functionality, certain features such as functions cannot be renamed.

\subsection{Modern JavaScript Project Optimizers\cite{zolotareva2014modern} }
The authors of this paper discuss the state of the art of JavaScript optimizers.
Tools discussed included JSMin, YUI Compressor, UglifierJS, Google Closure Compiler, and KJSCompiler and their respective benefits and drawbacks.
For instance, KJSCompiler is an extension to Google Closure Compiler where the users can annotate dependencies between files.
This is a useful tool to research, due to the fact that it may further reduce the size of JavaScript files and combine them into a single library.

\subsection{Characterizing and Detecting Performance Bugs for Smartphone Applications\cite{liu2014characterizing} }
This paper begins by presenting common patterns among performance bugs among popular, large scale Android applications.
Then, the presents PerfChecker, a static analysis tool that looks for those performance bugs (20 of which were fixed by developers).
This paper focuses on bugs relating to a native applicationâ€™s local code and potentially very specific causes for those bugs, such as activating multiple features in a specific sequence.
So, the guidelines presented here do not directly address hybrid mobile applications, although the approach or results could in some cases be adapted for hybrids.
There is little mention of web language bugs.

\subsection{High Performance Web Sites\cite{souders2008high}}
The paper discussed the importance of front-end performance.
It also lists best practices and shows why they are important.


\begin{enumerate}
	\item Make fewer HTTP requests
	\item Use a content delivery network
	\item Add an Expires header
	\item Gzip components
	\item Put stylesheets at the top
	\item Put scripts at the bottom
	\item Avoid CSS expressions
	\item Make JavaScript and CSS external
	\item Reduce DNS lookups
	\item Minify JavaScript
	\item Avoid redirects
	\item Remove duplicate scripts
	\item Configure ETags
	\item Make Ajax cacheable
\end{enumerate}


\bibliographystyle{plain}
\bibliography{sigproc-sp}


\end{document}
